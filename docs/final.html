<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>Fire Simulation Project  |  CS 184</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="style.css" media="screen" />
</head>
<body>
<div class="page">
    <div class="title">
        <h1>FireSim</h1>
        <h2>CS184 | Final Project</h2>
    </div>
    <div class="navbar">
        <table>
            <tr>
                <td><a href="index.html">Home</a></td>
                <td><a href="proposal.html">Proposal</a></td>
                <td><a href="milestone.html">Milestone</a></td>
                <td><a href="final.html">Final</a></td>
            </tr>
        </table>
    </div>
    <div class="content">
      <h1>Final Report</h1>
      <h2>Real-Time Fire Simulation</h2>
        <p>In our project we simulate real-time fire using a grid-based approach and fluid dynamics. We use the incompressible Navier-Stokes equations, which are broken down into 4 main components: advection, diffusion, external forces, and projection, to model the mechanics of the fluid. In order to visualize and successively test each of these components, initally we set up a 2D grid representing the fluid velocity field. To represent the fire, we added a fuel source which would be continuously generated in a circle at the bottom of the grid, with fuel depletion controlled by a reaction coordinate. Once we verified our calculations worked, we moved these computations from the CPU to the GPU and switched out our 2D texture for a 3D one. Next, we sampled images of real fire to obtain equations representing how the red, green, and blue color values varied with temperature. As a last step, we ray-trace through the 3D texture, accumulating temperature values along each ray, and use those quantities to calculate color. At a low performance cost, this allowed us to acheive relatively realistic looking fire effects in real-time.</p>
      <h2>Technical Approach</h2>
        <p>Our first step was setting up GLFW to use with the OpenGL library, which we referenced this source, <a href="https://learnopengl.com/">LearnOpenGL</a>, for. The source also suggested using GLAD to manage the cumbersome work of loading the relevant OpenGL functions, which can vary depending on the OpenGL version used. Initially, we tested our setup worked by opening an application window and getting a triangle to render to the screen. We also implemented basic camera controls that allowed the user to zoom in and out; the previously mentioned source had individual sections for each of these actions.</p>

        <p>Next, we referenced the <a href="https://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch38.html">GPU Gems 2D Fluid Sim</a> to gain a better understanding of the physics behind fluid simulation. For our fluid, as well as the one introduced in the source, we assume an incompressible, homogeneous fluid, which we begin by representing as a 2D grid; in the code itself, we also store a velocity and scalar pressure field. For each cell in the grid, we solve the Navier-Stokes equations, which can be broken down into advection, diffusion, external forces, and projection components. As we apply each component to our fluid, we visualize and test it, by first giving each cell in the grid an arrow representing the velocity at that point, and then later by adding a passive dye scalar which would be passively advected alongside the velocity. After testing for advection in this way, we applied diffusion to our fluid's velocity field, yielding a field with non-zero divergence. We must correct for this using the Helmholtz-Hodge Decomposition Theorem, in which we subtract the gradient of the fluid's pressure to obtain a field with divergence-free velocity. To do this requires the following steps, which make up the projection component of our Navier-Stokes equation:
        </p>
        <ul>
          <li>First we obtain a Poisson-pressure equation by applying divergence on our velocity field from earlier</li>
          <li>We can solve for the fluid's pressure in this equation using Jacobian iteration</li>
          <li>Finally, we can apply the gradient and subtract from our earlier velocity field to obtain a field with zero divergence</li>
        </ul>

        <p>After completing the Navier-Stokes fluid solver with CPU functions and verifying that we understood the mechanics of it, we began moving the implementation into GPU. We began by adding textures to store velocity, pressure, and divergence. Each step of the fluid solver was written as a separate GLSL frag shader and drawn into a framebuffer to perform the calculation. As a result, our program performance increased significantly; we were also able to increase the resolution of our 2D grid. While the CPU solver was only able to simulate up to a 100x100 grid without noticeable lag, the GPU solver could handle grid sizes of over 1500x1500.</p>

        <p>As a next step, we replace the dye with a texture representing the fuel quantity of the flame; this is also called the reaction coordinate, and the equation representing how this quantity changes, with respect to the fluid's velocity field, is referenced from <a href="https://physbam.stanford.edu/~fedkiw/papers/stanford2002-02.pdf">Nguyen's paper</a> on physically based simulation of fire. This equation can be solved using the semi-Lagrangian stable fluids method described above. To simulate the fuel being "consumed" by the combustion reaction, we decrease it linearly at every cell. Near the bottom of the grid, we place a fuel "source" (a circle at the base of the flame) which is continuously refilled at every time step.</p>

        <p>To increase the realism of our fire, we also began changing our current advection scheme to the MacCormack advection scheme described in the <a href="https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch30.html">GPU Gems 3D Fluid Sim</a> article. The current advection scheme we were using was unconditionally stable, but introduced unwanted numerical smoothing, causing the generated flame to look unnaturally smooth. In addition, we referenced the "Force Application" section of the <a href="https://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch38.html">GPU Gems 2D Fluid Sim</a> article to apply a random Gaussian splat to our flame, as well as added random bits of wind, to acheive a more realistic fire effect from random external forces.</p>

        <p>At this point, we began referencing the <a href="https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch30.html">GPU Gems 3D Fluid Sim</a> article to translate our 2D fluid computations to 3D. This involved adding an extra z-coordinate and tweaking our calculations in the GLSL frag shaders slightly to account for the extra dimension. Each shader, however, only operates on a single "slice", or 2D cross-section, of our 3D texture at a time. To generate a flame in 3D, we divide up our 3D texture into <code>grid_size + 2</code> slices and iterate over each slice, performing the fluid computations for that particular slice in the GLSL shaders.</p>

        <p>Having moved our implementation to 3D, we can then calculate temperature by </p>
      <h2>Results</h2>
      <h2>References</h2>
      <ul>
          <li><a href="https://learnopengl.com/">LearnOpenGL</a></li>
          <li><a href="https://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch38.html">GPU Gems 2D Fluid Sim</a></li>
          <li><a href="https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch30.html">GPU Gems 3D Fluid Sim</a></li>
          <li><a href="https://physbam.stanford.edu/~fedkiw/papers/stanford2002-02.pdf">Physically Based Modeling and Animation of Fire</a></li>
      </ul>
      <h2>Contributions</h2>
    </div>
</div>
</body>
</html>